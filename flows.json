[
    {
        "id": "57aed979d45b94dc",
        "type": "tab",
        "label": "EOS",
        "disabled": false,
        "info": "",
        "env": [
            {
                "name": "EOS_URL",
                "value": "http://<<<<ip-replace>>>>:8503",
                "type": "str"
            }
        ]
    },
    {
        "id": "c6d7c27cb63b9301",
        "type": "influxdb",
        "hostname": "<<<<ip-replace>>>>",
        "port": "8086",
        "protocol": "http",
        "database": "unknown",
        "name": "InfluxDB",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://<<<<ip-replace>>>>:8086",
        "timeout": "",
        "rejectUnauthorized": false
    },
    {
        "id": "0908e1e8147a336e",
        "type": "http request",
        "z": "57aed979d45b94dc",
        "name": "",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{eos_url}}}/optimize",
        "tls": "",
        "persist": true,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2790,
        "y": 520,
        "wires": [
            [
                "a53e7fcf06c23df8",
                "d633320e320bf056"
            ]
        ]
    },
    {
        "id": "e4b7fa2f4b0be015",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "function rule them all",
        "func": "context.data = context.data || {};\nswitch (msg.topic) {\n    case \"soc\": \n        context.data.soc = msg.payload;\n        return null;\n    case \"strompreis\":\n        //context.data.strompreis = msg.payload.map(p => p / 100); // Convert to euro/Wh\n        context.data.strompreis = msg.payload;\n        return null;        \n    case \"gesamtlast\":\n        context.data.gesamtlast = msg.payload.map(p => p * 1);; // Example multiplier for conversion\n        return null;               \n    case \"pv_forecast\":\n        //context.data.temperature_forecast = msg.payload.map(t => t + 18); // Example adjustment for temperatures\n        context.data.pv_forecast = msg.payload.map(v => v * 1000); // Convert to Wh\n        return null;                \n    case \"temperature_forecast\":\n        context.data.temperature_forecast = msg.payload;\n        return null; \n    case \"soc_tesla\":\n        context.data.soc_tesla = msg.payload;\n        return null;\n    case \"akku_preis\":\n        context.data.akku_preis = parseFloat(msg.payload);\n        return null;          \n    case \"eauto_soc_ui\":\n        context.data.eauto_soc_ui = parseFloat(msg.payload);\n        return null;        \n    case \"pvpowernow\":\n        context.data.pvpowernow = parseFloat(msg.payload);\n        return null;                \n    case \"solution\":\n        context.data.start_solution = msg.payload.start_solution;\n        return null;           \n    case \"spuel\":\n        context.data.spuel = msg.payload;\n        return null;     \n    case \"spuel_onoff\":\n        context.data.spuel_onoff = msg.payload;\n        return null;                        \n    case \"go shorty\":\n        break;   \n    default:\n        return null; \n}\n\n// Defaults for missing data\nif (context.data.strompreis == null){\n    console.log(\"Missing price data\");\n    return null;\n}\n\nif (context.data.akku_preis == null)\n    context.data.akku_preis = 7.0;\n\nif (context.data.eauto_soc_ui == null)\n    context.data.eauto_soc_ui = 20.0;\n\nif (context.data.pvpowernow == null)\n    context.data.pvpowernow = null;\n\nif (context.data.start_solution == null)\n    context.data.start_solution = null; // Example default solution\n\nif (context.data.soc == null || context.data.soc_tesla == null || context.data.eauto_soc_ui == null) {\n    return msg;\n}\n\nmsg.payload = {\n    ems: {\n        preis_euro_pro_wh_akku: context.data.akku_preis * (0.01 / 100.0),\n        einspeiseverguetung_euro_pro_wh: 7 / (1000.0 * 100.0),\n        gesamtlast: context.data.gesamtlast,\n        pv_prognose_wh: context.data.pv_forecast,\n        strompreis_euro_pro_wh: context.data.strompreis\n    },\n    pv_akku: {\n        capacity_wh: 12000,\n        charging_efficiency: 0.92,\n        discharging_efficiency: 0.92,\n        max_charge_power_w: 5700,\n        initial_soc_percentage: context.data.soc,\n        min_soc_percentage: 5,\n        max_soc_percentage: 100\n    },\n    inverter: {\n        max_power_wh: 15500\n    },\n    eauto: {\n        capacity_wh: 64000,\n        charging_efficiency: 0.88,\n        discharging_efficiency: 0.88,\n        max_charge_power_w: 11040,\n        initial_soc_percentage: context.data.soc_tesla,\n        min_soc_percentage: context.data.eauto_soc_ui,\n        max_soc_percentage: 100\n    },\n    temperature_forecast: context.data.temperature_forecast,\n    start_solution: context.data.start_solution\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2400,
        "y": 520,
        "wires": [
            [
                "fa34e763a4bccacc",
                "60698e16ebcbb221"
            ]
        ]
    },
    {
        "id": "fa34e763a4bccacc",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug-PayloadForOptimization",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2430,
        "y": 560,
        "wires": []
    },
    {
        "id": "a53e7fcf06c23df8",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug-ResultOfOptimization",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 3020,
        "y": 520,
        "wires": []
    },
    {
        "id": "98d72ca32188641c",
        "type": "inject",
        "z": "57aed979d45b94dc",
        "name": "Trigger all 30 Minutes",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "3600",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "true",
        "payloadType": "bool",
        "x": 130,
        "y": 560,
        "wires": [
            [
                "1fe8d1f9e2621bee",
                "9e29056dea8f746c"
            ]
        ]
    },
    {
        "id": "c74ea27f5b853cd7",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "pv forecast",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1570,
        "y": 900,
        "wires": []
    },
    {
        "id": "7c16e58d57d088e2",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "filterAndFormatPVForecastFromMidnight",
        "func": "// Hole das aktuelle Datum\nlet now = new Date();\n\n// Erstelle ein neues Array, um die gefilterten Werte zu speichern\nlet filteredData = [];\n\n// Durchlaufe das ursprüngliche Array und filtere nur Werte ab Mitternacht\nmsg.payload.forEach(item => {\n    // Konvertiere den Zeitstempel in ein Datum\n    let itemDate = new Date(item._time);\n\n    // Prüfe, ob der Zeitstempel ab Mitternacht heute liegt\n    //if (itemDate >= new Date(now.getFullYear(), now.getMonth(), now.getDate())) {\n        filteredData.push(item);\n    //}\n});\n\n// Schneide die Werte auf maximal 48 Einträge\nlet limitedData = filteredData.slice(0, 48);\n\n// Extrahiere die \"last\"-Werte, runde auf 2 Nachkommastellen und speichere sie in einem neuen Array\nlet pv_forecast = limitedData.map(item => item._value !== null ? parseFloat(item._value.toFixed(2)) : 0);\n\n// Setze das neue Array als Payload im gewünschten Format\nmsg.payload = pv_forecast;\nmsg.topic = \"pv_forecast\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1660,
        "y": 860,
        "wires": [
            [
                "c74ea27f5b853cd7",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "4b3194b8944cbea2",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "pv power now",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1580,
        "y": 1000,
        "wires": []
    },
    {
        "id": "4c7d16251cb392f9",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "formatpvPowerNow",
        "func": "let pvData = msg.payload; // Der aktuelle Payload, wie z.B. [{\"time\":\"1970-01-01T00:00:00.000Z\",\"total_pv\":2.85}]\n\n// Extrahiere den Wert von \"total_pv\" aus dem Payload\nlet totalPv = pvData[0]._value; // Annahme: Das erste Element des Arrays enthält den gewünschten Wert\n\n// Multipliziere den Wert mit 1000 und schneide die Nachkommastellen ab\nlet pvPowerNow = Math.floor(totalPv * 1000);\n\n// Setze den msg.payload so, dass er nur den Wert \"pvpowernow\" enthält\nmsg.payload = pvPowerNow;\nmsg.topic = \"total_pv\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 960,
        "wires": [
            [
                "4b3194b8944cbea2",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "1d23bac51185cf23",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "home battery soc from db",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1410,
        "y": 680,
        "wires": []
    },
    {
        "id": "e23883ae77b9da9d",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "formatSocNow",
        "func": "let pvData = msg.payload; // Der aktuelle Payload, z.B. [{\"time\":\"2024-09-05T15:28:29.000Z\",\"last\":39}]\n\n// Extrahiere den Wert von \"last\" aus dem Payload\nlet lastValue = pvData[0]._value; // Annahme: Das erste Element des Arrays enthält den gewünschten Wert\n\n// Setze den msg.payload so, dass er nur den Wert \"soc\" enthält\nmsg.payload = lastValue;\nmsg.topic = \"soc\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 640,
        "wires": [
            [
                "1d23bac51185cf23",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "4c89689f328215f9",
        "type": "delay",
        "z": "57aed979d45b94dc",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 860,
        "y": 1060,
        "wires": [
            [
                "bb23d5b51d906279"
            ]
        ]
    },
    {
        "id": "982909bae686458e",
        "type": "delay",
        "z": "57aed979d45b94dc",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 700,
        "y": 860,
        "wires": [
            [
                "a433938a8b56d5ba",
                "4c89689f328215f9",
                "3047bbcf8e62a313",
                "705cf3fac8e3b43b"
            ]
        ]
    },
    {
        "id": "2f7fe4242b61445c",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "car soc db - formatted",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2160,
        "y": 1320,
        "wires": []
    },
    {
        "id": "cfdc12658a116550",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "formatSocCarNow",
        "func": "// Der aktuelle Payload, z.B. [{\"time\":\"2024-09-05T15:28:29.000Z\",\"last\":39}]\nlet pvData = msg.payload;\n\ntry {\n    // Extrahiere den Wert von \"last\" aus dem Payload\n    let lastValue = pvData[0]._value; // Annahme: Das erste Element des Arrays enthält den gewünschten Wert\n\n    // Setze den msg.payload so, dass er nur den Wert \"soc_tesla\" enthält\n    msg.payload = lastValue;\n} catch (error) {\n    // Wenn ein Fehler auftritt, setze den Wert auf 30\n    msg.payload = 30;\n    node.error(\"Error extracting value. Set it to 30 as default: \" + error.message, msg);\n}\n\nmsg.topic = \"soc_tesla\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2150,
        "y": 1280,
        "wires": [
            [
                "2f7fe4242b61445c",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "05e62b5400189371",
        "type": "comment",
        "z": "57aed979d45b94dc",
        "name": "HARDCODED - Read car SOC - HARDCODED",
        "info": "",
        "x": 1670,
        "y": 1400,
        "wires": [],
        "icon": "node-red/alert.svg"
    },
    {
        "id": "933cd0a1bd26c138",
        "type": "inject",
        "z": "57aed979d45b94dc",
        "name": "Start Optimization once",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "go shorty",
        "x": 120,
        "y": 460,
        "wires": [
            [
                "7f7fb0958c43e80c"
            ]
        ]
    },
    {
        "id": "adbf109d81999ecc",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "car soc - target",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 600,
        "wires": []
    },
    {
        "id": "a8351ac200a9deaa",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "power from db",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 1200,
        "wires": []
    },
    {
        "id": "d633320e320bf056",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Prepare Payload for InfluxDBv2",
        "func": "let payload = [];\nlet tempArray = [];\n\n// Get the current time and round down to the nearest hour\nlet baseTime = new Date();\nbaseTime.setMinutes(0, 0, 0); // Set minutes, seconds, and milliseconds to 0\nlet label = \"\";\nif (msg.topic == \"go shorty\") {\n    label = \"ac_charge\";\n    tempArray = msg.payload.ac_charge;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours((i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                relative: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n\n    label = \"discharge_allowed\";\n    tempArray = msg.payload.discharge_allowed;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours((i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                discharge_allowed: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n\n    label = \"eautocharge_hours_float\";\n    tempArray = msg.payload.eautocharge_hours_float;\n\n    // If tempArray is null, initialize it as an array of 48 zeros\n    if (tempArray === null) {\n        tempArray = Array(48).fill(0);\n    }\n\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours(i);\n\n        payload.push({\n            measurement: label,\n            fields: {\n                eautocharge_hours_float: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n\n    label = \"akku_soc_pro_stunde\";\n    tempArray = msg.payload.result.akku_soc_pro_stunde;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours(baseTime.getHours() + (i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                akku_soc_pro_stunde: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n\n    label = \"EAuto_SoC_pro_Stunde\";\n    tempArray = msg.payload.result.EAuto_SoC_pro_Stunde;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours(baseTime.getHours() + (i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                EAuto_SoC_pro_Stunde: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n\n    label = \"Last_Wh_pro_Stunde_optimized\";\n    tempArray = msg.payload.result.Last_Wh_pro_Stunde;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours(baseTime.getHours() + (i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                Last_Wh_pro_Stunde_optimized: tempArray[i]\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n}\n\nif (msg.topic == \"gesamtlast\") {\n    label = \"Last_Wh_pro_Stunde_prognose\";\n    console.log(msg.payload);\n    tempArray = msg.payload;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        timestamp.setHours((i));\n\n        payload.push({\n            measurement: label,\n            fields: {\n                Last_Wh_pro_Stunde_prognose: tempArray[i] * 1000\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n}\n\nif (msg.topic == \"strompreis\") {\n    label = \"strompreis_prognose\";\n    console.log(msg.payload);\n    tempArray = msg.payload;\n    for (let i = 0; i < tempArray.length; i++) {\n        // Calculate the timestamp for each hour in the past\n        let timestamp = new Date(baseTime);\n        //timestamp = timestamp.setHours((i));\n        //timestamp = new Date(timestamp);\n        timestamp.setHours((i));\n        payload.push({\n            measurement: label,\n            fields: {\n                strompreis_prognose: tempArray[i] * 1000\n            },\n            tags: {\n                source: label\n            },\n            timestamp: timestamp\n        });\n    }\n}\n\n\n// Set the new payload\nmsg.payload = payload;\nmsg.precision =\"ms\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3010,
        "y": 1160,
        "wires": [
            [
                "8a4d264f13d8b99d",
                "5555c5e9ff642de1"
            ]
        ]
    },
    {
        "id": "8a4d264f13d8b99d",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug-PayloadForInfluxDB",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 3300,
        "y": 1160,
        "wires": []
    },
    {
        "id": "4e361d4ec619345e",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Set target soc (car)",
        "func": "msg.topic = \"eauto_soc_ui\";\nmsg.payload = 60;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 560,
        "wires": [
            [
                "adbf109d81999ecc",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "a433938a8b56d5ba",
        "type": "delay",
        "z": "57aed979d45b94dc",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 860,
        "y": 1160,
        "wires": [
            [
                "278d19dbae951fc8"
            ]
        ]
    },
    {
        "id": "9ad59d0277ea8d49",
        "type": "delay",
        "z": "57aed979d45b94dc",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 560,
        "y": 1280,
        "wires": [
            [
                "323964f13fa2af16",
                "9523c491b8336aea"
            ]
        ]
    },
    {
        "id": "3a87f587546d135d",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "formatSocCarNow",
        "func": "let pvData = msg.payload; // Der aktuelle Payload, z.B. [{\"time\":\"2024-09-05T15:28:29.000Z\",\"last\":39}]\n\n// Extrahiere den Wert von \"last\" aus dem Payload\n//let lastValue = pvData[0].last; // Annahme: Das erste Element des Arrays enthält den gewünschten Wert\nlet lastValue = 10;\n// Setze den msg.payload so, dass er nur den Wert \"soc_tesla\" enthält\nmsg.payload = lastValue;\nmsg.topic = \"soc_tesla\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1710,
        "y": 1440,
        "wires": [
            [
                "2c2b85ee014af363",
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "1ddbed1bd2b221cf",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "car soc - db",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 1320,
        "wires": []
    },
    {
        "id": "2c2b85ee014af363",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug 59",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1480,
        "wires": []
    },
    {
        "id": "701b3d9437f44896",
        "type": "inject",
        "z": "57aed979d45b94dc",
        "name": "Create plan for EVCC",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 1480,
        "wires": [
            [
                "72aa6d9c085b25d0"
            ]
        ]
    },
    {
        "id": "3b3ee7e54f895753",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug 60",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 320,
        "y": 1520,
        "wires": []
    },
    {
        "id": "20bbc91dcbfd389d",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Create a Plan",
        "func": "// Input payload\nconst inputPayload = msg.payload;\nconst outputPayload = [];\n\n// Helper function to create entries for each minute\nfunction createMinuteEntries(startTime, loadbattery,timeshift, minutes, casemessage) {\n    const entries = [];\n    const baseTime = new Date(startTime).getTime(); // Convert to milliseconds\n    for (let i = timeshift; i < (timeshift + minutes); i++) {\n        const timestamp = (baseTime +timeshift+ i * 60 * 1000); // Convert to nanoseconds\n        const loadValue = loadbattery;\n        entries.push({\n            measurement: \"1loadbattery1\",\n            fields: {\n                loadbattery: loadValue\n            },\n            tags: {\n                source: \"1loadbattery1\",\n                usedcase : casemessage\n            },\n            timestamp // Nanoseconds\n        });\n    }\n    return entries;\n}\n\n// Main processing loop\ninputPayload.forEach((entry, index) => {\n    const value = entry._value;\n    const startTime = entry._time;\n    const previousEntry = inputPayload[index - 1];\n    const nextEntry = inputPayload[index + 1];\n\n    if (value === 0) {\n        // Case: Value is 0\n        outputPayload.push(...createMinuteEntries(startTime, 0,0, 0,\"0\"));\n    } else if (value === 1) {\n        // Case: Value is 1\n        outputPayload.push(...createMinuteEntries(startTime, 1,0, 60,\"1\"));\n    } else {\n        // Case: Value is between 0 and 1\n        const minutestoload = Math.round(value * 60);\n        const prevIsOne = previousEntry && previousEntry._value > 0;\n        const nextIsOne = nextEntry && nextEntry._value > 0;\n\n        if (prevIsOne && nextIsOne) {\n            const dividedMinutes = Math.round(minutestoload / 2);\n            outputPayload.push(...createMinuteEntries(startTime, 1,0, dividedMinutes,\"a\"));\n            outputPayload.push(...createMinuteEntries(startTime, 0,dividedMinutes, 60 - minutestoload,\"a\"));\n            outputPayload.push(...createMinuteEntries(startTime, 1,dividedMinutes + 60 - minutestoload, dividedMinutes,\"a\"));\n        } else if (prevIsOne && (!nextIsOne || !nextEntry)) {\n            outputPayload.push(...createMinuteEntries(startTime, 1,0, minutestoload,\"b\"));\n            outputPayload.push(...createMinuteEntries(startTime, 0,minutestoload, 60 - minutestoload,\"b\"));\n        } else if ((!previousEntry || previousEntry._value === 0) && nextIsOne) {\n            outputPayload.push(...createMinuteEntries(startTime, 0,0, 60 - minutestoload,\"c\"));\n            outputPayload.push(...createMinuteEntries(startTime, 1, 60 - minutestoload, minutestoload,\"c\"));\n        } else if ((!prevIsOne && !nextIsOne)) {\n            const dividedMinutes = Math.round((60 - minutestoload) / 2);\n            outputPayload.push(...createMinuteEntries(startTime, 0,0, dividedMinutes,\"d\"));\n            outputPayload.push(...createMinuteEntries(startTime, 1,dividedMinutes, minutestoload,\"d\"));\n            outputPayload.push(...createMinuteEntries(startTime, 0,dividedMinutes+minutestoload, dividedMinutes,\"d\"));\n        }\n    }\n});\n\nmsg.payload = outputPayload;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 1480,
        "wires": [
            [
                "2d8b5b186de98f21",
                "efc57fab159f0dfb"
            ]
        ]
    },
    {
        "id": "2d8b5b186de98f21",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "debug 61",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 1520,
        "wires": []
    },
    {
        "id": "60698e16ebcbb221",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Set Timeout",
        "func": "msg.httpRequestTimeout = 240000;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2610,
        "y": 520,
        "wires": [
            [
                "0908e1e8147a336e"
            ]
        ]
    },
    {
        "id": "13e83e16774bf495",
        "type": "comment",
        "z": "57aed979d45b94dc",
        "name": "IN PROGRESS - Prepare a plan for EVCC and write it in influxDB - IN PROGRESS",
        "info": "",
        "x": 450,
        "y": 1440,
        "wires": []
    },
    {
        "id": "2",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Transform power from db",
        "func": "// Access the array from msg.payload\nlet dataArray = msg.payload;\n\n// Define the result object\nlet result = {\n    start_datetime: dataArray[0]._time.replace(\"T\", \" \").replace(\"Z\", \"\"), // Take start from the first item\n    interval: \"1 hour\",\n    measurement_load0_mr: [] // Initialize an empty array for values\n};\n\n// Iterate through the data array and extract _value as integers\ndataArray.forEach(item => {\n    if (item._value !== undefined) {\n        result.measurement_load0_mr.push(Math.round(item._value)); // Round the value to nearest integer\n        //result.measurement_load0_mr.push(item._value); // Round the value to nearest integer\n    }\n});\n\n// Assign the result object back to msg.payload\nmsg.payload = result;\n\n// Return the modified message\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 1160,
        "wires": [
            [
                "3",
                "b956fa4fe3ac2cd2"
            ]
        ]
    },
    {
        "id": "3",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "power from db - transformed",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1200,
        "wires": []
    },
    {
        "id": "b956fa4fe3ac2cd2",
        "type": "http request",
        "z": "57aed979d45b94dc",
        "name": "",
        "method": "PUT",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{eos_url}}}/v1/measurement/data",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1610,
        "y": 1160,
        "wires": [
            [
                "742c0cefdcb4fd31",
                "10c18fe6e30a2f18"
            ]
        ]
    },
    {
        "id": "742c0cefdcb4fd31",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "power measurement",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1640,
        "y": 1220,
        "wires": []
    },
    {
        "id": "10c18fe6e30a2f18",
        "type": "http request",
        "z": "57aed979d45b94dc",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{eos_url}}}/v1/prediction/list?key=load_mean",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1870,
        "y": 1160,
        "wires": [
            [
                "5f407533913a270d",
                "a047bdc2cfc8d52e"
            ]
        ]
    },
    {
        "id": "f3a61e9d07624f19",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "gesamtlast",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2230,
        "y": 1160,
        "wires": [
            [
                "e4b7fa2f4b0be015",
                "d633320e320bf056"
            ]
        ]
    },
    {
        "id": "bb23d5b51d906279",
        "type": "http request",
        "z": "57aed979d45b94dc",
        "name": "Read price prediction from EOS",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{eos_url}}}/v1/prediction/list?key=elecprice_marketprice_wh&start_datetime={{{start_datetime}}}&end_datetime={{{end_datetime}}}",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1310,
        "y": 1060,
        "wires": [
            [
                "c362bb15047af916",
                "dd7e494b57590c5b"
            ]
        ]
    },
    {
        "id": "c362bb15047af916",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "price prediction from eos",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1290,
        "y": 1100,
        "wires": []
    },
    {
        "id": "5f407533913a270d",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "power prediction",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1880,
        "y": 1220,
        "wires": []
    },
    {
        "id": "5555c5e9ff642de1",
        "type": "influxdb batch",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "precision": "",
        "retentionPolicy": "",
        "name": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "<<<<name-replace>>>>",
        "bucket": "eos",
        "x": 3260,
        "y": 1120,
        "wires": []
    },
    {
        "id": "efc57fab159f0dfb",
        "type": "influxdb batch",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "precision": "",
        "retentionPolicy": "",
        "name": "Write plan to InfluxDB",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "<<<<name-replace>>>>",
        "bucket": "eos",
        "x": 1020,
        "y": 1480,
        "wires": []
    },
    {
        "id": "b02a6d33f9efea02",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "Read PV-Forecast from db",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 1280,
        "y": 860,
        "wires": [
            [
                "7c16e58d57d088e2"
            ]
        ]
    },
    {
        "id": "3047bbcf8e62a313",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "Read total_pv from db",
        "query": "from(bucket: \"evcc\")\n  |> range(start: -10m, stop: 0m)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"pvPower\")\n  |> filter(fn: (r) => r[\"_field\"] == \"value\")\n  |> filter(fn: (r) => r[\"id\"] == \"1\" or r[\"id\"] == \"2\")\n  |> last()  // Selects the last value directly\n  |> group()\n  |> aggregateWindow(every: 1h, fn: sum, createEmpty: false)\n  |> yield(name: \"last\")",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 1260,
        "y": 960,
        "wires": [
            [
                "4c7d16251cb392f9"
            ]
        ]
    },
    {
        "id": "4c7b1d3116aff6f7",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "Read soc (home) from db",
        "query": "from(bucket: \"evcc\")\n  |> range(start: -10m, stop: 0m)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"batterySoc\")\n  |> filter(fn: (r) => r[\"_field\"] == \"value\")\n  |> filter(fn: (r) => r[\"id\"] == \"1\")\n  |> last()  // Selects the last value directly\n  |> yield(name: \"mean\")",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 1080,
        "y": 640,
        "wires": [
            [
                "e23883ae77b9da9d"
            ]
        ]
    },
    {
        "id": "278d19dbae951fc8",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "read power from db",
        "query": "from(bucket: \"evcc\")\n  |> range(start: -58h, stop: 0m)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"homePower\")\n  |> filter(fn: (r) => r[\"_field\"] == \"value\")\n  |> aggregateWindow(every: 1h, fn: mean, createEmpty: false)\n  |> yield(name: \"mean\")",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 1050,
        "y": 1160,
        "wires": [
            [
                "a8351ac200a9deaa",
                "2"
            ]
        ]
    },
    {
        "id": "323964f13fa2af16",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "Read soc (car) from db",
        "query": "import \"math\"\nfrom(bucket: \"evcc\")\n  |> range(start: -150h, stop: 0h)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"vehicleSoc\")\n  |> filter(fn: (r) => r[\"_value\"] != 0)  // Filter out values where _value is 0\n  |> aggregateWindow(every: 30m, fn: last, createEmpty: false)\n  |> last()  // Selects the last value directly\n  |> map(fn: (r) => ({ r with _value: math.round(x: r._value) }))  // Round down the _value\n  |> yield(name: \"last\")",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 950,
        "y": 1280,
        "wires": [
            [
                "cfdc12658a116550",
                "1ddbed1bd2b221cf"
            ]
        ]
    },
    {
        "id": "72aa6d9c085b25d0",
        "type": "influxdb in",
        "z": "57aed979d45b94dc",
        "influxdb": "c6d7c27cb63b9301",
        "name": "Read EOS result from InfluxDB",
        "query": "from(bucket: \"eos\")\n  |> range(start: -24h, stop: 48h)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ac_charge\")\n  |> yield(name: \"mean\")",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "<<<<name-replace>>>>",
        "x": 390,
        "y": 1480,
        "wires": [
            [
                "3b3ee7e54f895753",
                "20bbc91dcbfd389d"
            ]
        ]
    },
    {
        "id": "1fe8d1f9e2621bee",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "eos_url",
                "pt": "msg",
                "to": "EOS_URL",
                "tot": "env",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 370,
        "y": 560,
        "wires": [
            [
                "9ad59d0277ea8d49",
                "4c7b1d3116aff6f7",
                "4e361d4ec619345e",
                "d116187b8aaf13a7"
            ]
        ]
    },
    {
        "id": "7f7fb0958c43e80c",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "eos_url",
                "pt": "msg",
                "to": "EOS_URL",
                "tot": "env",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 540,
        "y": 500,
        "wires": [
            [
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "9e29056dea8f746c",
        "type": "delay",
        "z": "57aed979d45b94dc",
        "name": "",
        "pauseType": "delay",
        "timeout": "20",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 120,
        "y": 500,
        "wires": [
            [
                "7b08a5b0c8fc1f87"
            ]
        ]
    },
    {
        "id": "7b08a5b0c8fc1f87",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "go shorty",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 270,
        "y": 500,
        "wires": [
            [
                "7f7fb0958c43e80c"
            ]
        ]
    },
    {
        "id": "e2cd68e62e64e2d6",
        "type": "comment",
        "z": "57aed979d45b94dc",
        "name": "Readme",
        "info": "# How to use this flow\n\n## Install dependencies\n 1. Click on the top right burger bar icon\n 2. Click on manage palette\n 3. Search for node-red-contrib-influxdb\n 4. Install\n\n## Configure InfluxDB settings\n 1. Double click on one influx db node\n 2. Adjust the InfluxDB settings\n\n\n## This Flow is using environment variables.\n- double click on the flow name on the top left\n- click on the \"list\" icon below \"done\" and next to the settings icon\n- change IP and port\n\n## Write to InfluxDB\nThis flow writes data to influx db and expects a eos bucket",
        "x": 420,
        "y": 400,
        "wires": []
    },
    {
        "id": "dd3380c0c5e2d7f5",
        "type": "comment",
        "z": "57aed979d45b94dc",
        "name": "ToDo List",
        "info": "- Replace PV-Forecast nodes with https://akkudoktor-eos.readthedocs.io/en/latest/akkudoktoreos/prediction.html#pv-power-prediction\n- Add error handling and logging\n- Use variables in read influx DB nodes (bucket_names)\n- Use variables in write influx DB nodes\n- Add EVCC Integration\n-\n",
        "x": 640,
        "y": 400,
        "wires": []
    },
    {
        "id": "a210ffdef6f2bc41",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "temperature_forecast",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1110,
        "y": 1380,
        "wires": [
            [
                "c0a46c77df270800",
                "c8c29f8b8b9bdf8c"
            ]
        ]
    },
    {
        "id": "a047bdc2cfc8d52e",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "verify power",
        "func": "// Überprüfe, ob die Payload ein Array ist\nif (Array.isArray(msg.payload)) {\n    // Iteriere durch das Array und prüfe, ob jeder Wert eine Zahl ist\n    for (let i = 0; i < msg.payload.length; i++) {\n        if (isNaN(msg.payload[i])) {\n            // Wenn der Wert keine Zahl ist, setze ihn auf 500\n            msg.payload[i] = 500;\n        } else {\n            // Wenn der Wert eine Zahl ist, konvertiere ihn zu einer Zahl (falls nötig)\n            msg.payload[i] = Number(msg.payload[i]);\n        }\n    }\n    \n    // Überprüfe, ob das Array 48 Einträge hat, wenn nicht, fülle es mit 500 auf\n    while (msg.payload.length < 48) {\n        msg.payload.push(500);\n    }\n    \n    // Wenn das Array mehr als 48 Einträge hat, kürze es auf 48\n    if (msg.payload.length > 48) {\n        msg.payload = msg.payload.slice(0, 48);\n    }\n} else {\n    // Wenn msg.payload kein Array ist, erstelle ein Array mit 48 Einträgen, die den Wert 500 haben\n    node.warn(\"Die Payload ist kein Array! Erstelle ein Array mit 48 Einträgen.\");\n    \n    // Array mit 48 Werten, die jeweils 500 sind\n    msg.payload = new Array(48).fill(500);  // Füllt das Array mit 48 Einträgen, die den Wert 500 haben\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2070,
        "y": 1160,
        "wires": [
            [
                "757914590366c534",
                "f3a61e9d07624f19"
            ]
        ]
    },
    {
        "id": "757914590366c534",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "power prediction - verification",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2120,
        "y": 1220,
        "wires": []
    },
    {
        "id": "ca37cb9454e035c6",
        "type": "inject",
        "z": "57aed979d45b94dc",
        "name": "Inject working test payload",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "go shorty",
        "payload": "{\"ems\":{\"preis_euro_pro_wh_akku\":0.0007,\"einspeiseverguetung_euro_pro_wh\":0.00007,\"gesamtlast\":[500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500],\"pv_prognose_wh\":[300,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,180,960,2230,4019.9999999999995,5050,7570,1160,420,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,410,1160,1610,2050,2029.9999999999998,2160,1840],\"strompreis_euro_pro_wh\":[0.0003784,0.0003868,0.0003899,0.0003725,0.0003653,0.0003247,0.0003158,0.0003069,0.0002886,0.0003163,0.0003111,0.0003049,0.0003019,0.0003059,0.0003154,0.0003228,0.0003802,0.0003815,0.0003672,0.0003369,0.0003181,0.0003131,0.0003137,0.0003162,0.0003342,0.0003698,0.0003899,0.0003905,0.000386,0.0003689,0.0003543,0.0003452,0.0003301,0.0003105,0.0003092,0.00030561,0.00030459,0.00030252,0.00030428,0.00031222,0.00033462,0.00036252,0.00038452,0.00037676,0.00036253,0.00035264,0.00034102,0.00033709]},\"pv_akku\":{\"capacity_wh\":12000,\"charging_efficiency\":0.92,\"discharging_efficiency\":0.92,\"max_charge_power_w\":5700,\"initial_soc_percentage\":66,\"min_soc_percentage\":5,\"max_soc_percentage\":100},\"inverter\":{\"max_power_wh\":15500},\"eauto\":{\"capacity_wh\":64000,\"charging_efficiency\":0.88,\"discharging_efficiency\":0.88,\"max_charge_power_w\":11040,\"initial_soc_percentage\":98,\"min_soc_percentage\":60,\"max_soc_percentage\":100},\"temperature_forecast\":[18.3,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18.02,18.18,18.96,20.23,22.02,23.05,25.57,19.16,18.42,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18.01,18.41,19.16,19.61,20.05,20.03,20.16,19.84],\"start_solution\":null}",
        "payloadType": "json",
        "x": 2410,
        "y": 480,
        "wires": [
            [
                "175bf928862d4dc3"
            ]
        ]
    },
    {
        "id": "9523c491b8336aea",
        "type": "http request",
        "z": "57aed979d45b94dc",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{eos_url}}}/v1/prediction/list?key=weather_temp_air",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 910,
        "y": 1380,
        "wires": [
            [
                "a210ffdef6f2bc41"
            ]
        ]
    },
    {
        "id": "c0a46c77df270800",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "temperatur prediction",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1140,
        "y": 1420,
        "wires": []
    },
    {
        "id": "c8c29f8b8b9bdf8c",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "verify power",
        "func": "// Überprüfe, ob die Payload ein Array ist\nif (Array.isArray(msg.payload)) {\n    // Iteriere durch das Array und prüfe, ob jeder Wert eine Zahl ist\n    for (let i = 0; i < msg.payload.length; i++) {\n        if (isNaN(msg.payload[i])) {\n            // Wenn der Wert keine Zahl ist, setze ihn auf 500\n            msg.payload[i] = 500;\n        } else {\n            // Wenn der Wert eine Zahl ist, konvertiere ihn zu einer Zahl (falls nötig)\n            msg.payload[i] = Number(msg.payload[i]);\n        }\n    }\n    \n    // Überprüfe, ob das Array 48 Einträge hat, wenn nicht, fülle es mit 500 auf\n    while (msg.payload.length < 48) {\n        msg.payload.push(500);\n    }\n    \n    // Wenn das Array mehr als 48 Einträge hat, kürze es auf 48\n    if (msg.payload.length > 48) {\n        msg.payload = msg.payload.slice(0, 48);\n    }\n} else {\n    // Wenn msg.payload kein Array ist, erstelle ein Array mit 48 Einträgen, die den Wert 500 haben\n    node.warn(\"Die Payload ist kein Array! Erstelle ein Array mit 48 Einträgen.\");\n    \n    // Array mit 48 Werten, die jeweils 500 sind\n    msg.payload = new Array(48).fill(6);  // Füllt das Array mit 48 Einträgen, die den Wert 500 haben\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 1380,
        "wires": [
            [
                "e4b7fa2f4b0be015"
            ]
        ]
    },
    {
        "id": "175bf928862d4dc3",
        "type": "change",
        "z": "57aed979d45b94dc",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "eos_url",
                "pt": "msg",
                "to": "EOS_URL",
                "tot": "env",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2620,
        "y": 480,
        "wires": [
            [
                "0908e1e8147a336e"
            ]
        ]
    },
    {
        "id": "41fe7eadbc39a647",
        "type": "inject",
        "z": "57aed979d45b94dc",
        "name": "Start Preparation once",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "5",
        "topic": "",
        "payload": "true",
        "payloadType": "bool",
        "x": 120,
        "y": 620,
        "wires": [
            [
                "1fe8d1f9e2621bee"
            ]
        ]
    },
    {
        "id": "d116187b8aaf13a7",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Create start & end datetime",
        "func": "// Get the current date in Germany timezone\nlet date = new Date();\nlet utcdate_start = new Date(date.toLocaleString(\"de-DE\", { timeZone: \"Europe/Berlin\" }));\nutcdate_start.setHours(0, 0, 0, 0);\nlet utcdate_end = new Date(utcdate_start);\n// Add 2 days\nutcdate_end.setDate(utcdate_end.getDate() + 2);\n\nutcdate_start.toLocaleString(\"de-DE\", { timeZone: \"Europe/Berlin\" })\nutcdate_end.toLocaleString(\"de-DE\", { timeZone: \"Europe/Berlin\" })\n\n// Format it as \"2025-02-02T00:00:00.000Z\"\nutcdate_end = utcdate_end.toISOString();\nutcdate_start = utcdate_start.toISOString();\n\n// Set time to 00:00 in Germany timezone\nlet options = {\n    timeZone: \"Europe/Berlin\",\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hourCycle: \"h23\"\n};\n\n// Format the date using Berlin's timezone\nlet germanyDate = new Intl.DateTimeFormat(\"de-DE\", options).formatToParts(date);\n\n// Extract date components\nlet year = germanyDate.find((p) => p.type === \"year\").value;\nlet month = germanyDate.find((p) => p.type === \"month\").value;\nlet day = germanyDate.find((p) => p.type === \"day\").value;\nlet hour = \"00\";\nlet minute = \"00\";\nlet second = \"00\";\n\n// Get the timezone offset dynamically for Berlin\nlet berlinTime = new Date().toLocaleString(\"en-US\", { timeZone: \"Europe/Berlin\", timeZoneName: \"longOffset\" });\n\n// Extract the offset from the formatted string (e.g., \"GMT+01:00\" or \"GMT+02:00\")\nlet offsetMatch = berlinTime.match(/GMT([+-]\\d{2}):(\\d{2})/);\n\nlet sign = \"+\";\nlet offsetHours = \"01\"; // Default to Germany's winter time (UTC+1)\nlet offsetMinutes = \"00\";\n\n// If match is found, extract the correct offset\nif (offsetMatch) {\n    sign = offsetMatch[1][0]; // + or -\n    offsetHours = offsetMatch[1].slice(1).padStart(2, '0'); // 01 or 02\n    offsetMinutes = offsetMatch[2].padStart(2, '0'); // 00\n}\n\n// Construct Berlin time in ISO format\nlet startDate = `${year}-${month}-${day}T${hour}:${minute}:${second}${sign}${offsetHours}:${offsetMinutes}`;\n\n// Calculate end date (48h after start date)\nlet startDateObj = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);\nstartDateObj.setHours(startDateObj.getHours() + 48); // Add 48 hours\n\n// Extract the new end date components\nlet endYear = startDateObj.getFullYear();\nlet endMonth = String(startDateObj.getMonth() + 1).padStart(2, '0'); // Months are 0-based\nlet endDay = String(startDateObj.getDate()).padStart(2, '0');\n\n// Construct end date in ISO format\nlet endDate = `${endYear}-${endMonth}-${endDay}T${hour}:${minute}:${second}${sign}${offsetHours}:${offsetMinutes}`;\n\n// URL encode the datetime strings\nmsg.start_datetime = encodeURIComponent(startDate);\nmsg.end_datetime = encodeURIComponent(endDate);\nmsg.utcdate_start = startDate;\nmsg.utcdate_end = endDate;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 740,
        "wires": [
            [
                "5d88ef9680d42093",
                "982909bae686458e"
            ]
        ]
    },
    {
        "id": "5d88ef9680d42093",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "Start & Endtime",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 780,
        "wires": []
    },
    {
        "id": "dd7e494b57590c5b",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "price adjusted from eos",
        "func": "msg.payload = msg.payload.map(p => p * 1.1894 - 0.00003778);\nmsg.topic = \"strompreis\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 1060,
        "wires": [
            [
                "0dcd1771a41460a2",
                "e4b7fa2f4b0be015",
                "d633320e320bf056"
            ]
        ]
    },
    {
        "id": "0dcd1771a41460a2",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "price adjusted from eos",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1610,
        "y": 1100,
        "wires": []
    },
    {
        "id": "705cf3fac8e3b43b",
        "type": "function",
        "z": "57aed979d45b94dc",
        "name": "Prepare Payload for PV",
        "func": "msg.query = `\nfrom(bucket: \"pvforecast\")\n  |> range(start: ${msg.utcdate_start}, stop: ${msg.utcdate_end})\n  |> filter(fn: (r) => r[\"_measurement\"] == \"solcast-HuetteOst\" or r[\"_measurement\"] == \"solcast-SüdWest\")\n  |> filter(fn: (r) => r[\"_field\"] == \"pv_estimate\")\n  |> group(columns: [\"_time\", \"pv_estimate\"])\n  |> sum()\n  |> group(columns: [\"pv_estimate\"])\n  |> sort(columns: [\"_time\"])\n  |> aggregateWindow(every: 1h, fn: last, createEmpty: false)\n  |> yield(name: \"mean\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 860,
        "wires": [
            [
                "b02a6d33f9efea02",
                "d0a1955a8248868f"
            ]
        ]
    },
    {
        "id": "d0a1955a8248868f",
        "type": "debug",
        "z": "57aed979d45b94dc",
        "name": "Read PV-Forecast from db",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 900,
        "wires": []
    }
]